---
releaseDate: "2021-02-15"
title: "Setting up a startup's staging environment"
category: "engineering"
tags: ["devops", "design"]
description: "How to settup a simple staging environment based on a gitops approach coupled with a k8s infrastructure"
---

_To illustrate this article, you can find the github repository
[Dot-H/simple-staging-env-ex](https://github.com/Dot-H/simple-staging-env-ex)_

At eKee, when the team and the number of users started growing, we had an issue.
We wanted to test things out and propose different versions of the product to
the users. Issue being we were a startup and duplicating the environment was way
to expensive.

In this article, I'll shortly explain our backend architecture, the solution I
went to, the tools used to develop it and its limitations.

## The backend environment

At eKee we had an **hybrid architecture**. Without the fancy words, it just means
that our stateful services (_databases_, _knowledge base software_, _gitlab_...)
were running on on-premise servers while the stateless services
(_engine_, _api_, _websites_...) were running in a cloud infrastructure using
kubernetes.

Everything was deployed using a gitops approach, taging a new version of a service
would trigger a new deployment. In order to do so, we were using
[**ansible**](https://docs.ansible.com/ansible/latest/index.html) for on-premise
services and [**helm**](https://helm.sh/) coupled with
[**argocd**](https://argo-cd.readthedocs.io/en/stable/) for the in-cloud services.

## The specification

Based on this environment, here is what I wanted to develop:

- Expose a `staging.[service]` subdomain for each service which would resolve to
  a specific version of this service;
- The version of a service could be any of its branch on git. If I want to test
  _feature-A_ on the _ekee-api_ service I would deploy the latest commit on branch
  _feature-A_;
- Each service in the staging environment can use a different branch. They can be
  deployed independantly;
- The staging environment relies as much as it can on the prod one, no extra
  deployment needed;
- Deployments must be **simple**. If the developers needs to do more than two
  operations, they won't use it (we all know we are lazy kind of people).

Following this specification, here is the developer experience I wanted:

1. **Developer A** develops a new interface to share documents. The branch
   _doc-sharing-v2_ is created in the repository _ekee-dashboard_,
1. After commiting some beautiful engineering, **Developer A** opens a pull
   request and labels it _staging_,
1. Once the CI returns no error, **Developer A** clicks _deploy_ in _argocd_,
1. When the PR is closed and/or the label **staging** is removed, the resources
   used by in the staging environment are released.

## The implementation

### Adding the workflow around the _staging_ label in github

To trigger special workflows upon specific events, github exposes a wonderful
set of tools through what they call [github actions](https://docs.github.com/en/actions).

Here is the action we need to tag the latest PR's commit when the _staging_ label
is present and untag it when the PR is closed or unlabeled:

```yaml
name: Staging environment management
on:
  pull_request:
    types: [opened, closed, synchronize, reopened, labeled, unlabeled]
jobs:
  tag:
    if: ${{ !contains(github.event.pull_request.labels.*.name, 'no-ci') }}
    name: Tag staging
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 1
      # Retrieve the branch name
      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_HEAD_REF}" >> $GITHUB_OUTPUT
        id: extract_branch
      # Tag the current commit with `staging-BRANCH_NAME` when there is a `staging` label
      - name: "Tag staging"
        uses: eKee-io/git-tag-action@fix-not-a-git-dir
        # Ensure that this step only runs if the staging label is present and the
        # action is not "closed" nor "unlabeled"
        if:
          ${{ !contains(fromJson('["unlabeled", "closed"]'), github.event.action)
          && contains(github.event.pull_request.labels.*.name, 'staging') }}
        env:
          TAG: staging-${{ steps.extract_branch.outputs.branch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ steps.extract_branch.outputs.branch }}
      # Delete the `staging-BRANCH_NAME` tag if the PR is closed or unlabeled
      - name: "Untag staging"
        uses: eKee-io/git-tag-action@fix-not-a-git-dir
        if: ${{ contains(github.event.action, 'closed') ||
          (contains(github.event.action, 'unlabeled')
          && !contains(github.event.pull_request.labels.*.name, 'staging')) }}
        env:
          TAG: staging-${{ steps.extract_branch.outputs.branch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ steps.extract_branch.outputs.branch }}
          DELETE: true
```

So basically everything it does is just managing the staging tag. And since our
environment was already triggering an image building upon tagging event, the gitops
part is already done!

### Building the staging image to deploy

Nothing fancy here! What we deploy is a docker image so the strategy is pretty simple:

1. Put a Dockerfile in the root directory of the services,
1. Add an action triggered on tagging events building the docker image,
1. Tag the docker image with the same tag as git,
1. Push this image to your registry in order for it to be accessible by
   your cloud resources.

### Deploying the resources in k8s
